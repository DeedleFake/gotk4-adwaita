// Code generated by girgen. DO NOT EDIT.

package adw

import (
	"fmt"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gtk/v4"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: libadwaita-1
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <adwaita.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.adw_flap_fold_policy_get_type()), F: marshalFlapFoldPolicy},
		{T: externglib.Type(C.adw_flap_transition_type_get_type()), F: marshalFlapTransitionType},
		{T: externglib.Type(C.adw_flap_get_type()), F: marshalFlapper},
	})
}

// FlapFoldPolicy: these enumeration values describe the possible folding
// behavior in a Flap widget.
type FlapFoldPolicy int

const (
	// FlapFoldPolicyNever: disable folding, the flap cannot reach narrow sizes.
	FlapFoldPolicyNever FlapFoldPolicy = iota
	// FlapFoldPolicyAlways: keep the flap always folded.
	FlapFoldPolicyAlways
	// FlapFoldPolicyAuto: fold and unfold the flap based on available space.
	FlapFoldPolicyAuto
)

func marshalFlapFoldPolicy(p uintptr) (interface{}, error) {
	return FlapFoldPolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for FlapFoldPolicy.
func (f FlapFoldPolicy) String() string {
	switch f {
	case FlapFoldPolicyNever:
		return "Never"
	case FlapFoldPolicyAlways:
		return "Always"
	case FlapFoldPolicyAuto:
		return "Auto"
	default:
		return fmt.Sprintf("FlapFoldPolicy(%d)", f)
	}
}

// FlapTransitionType: these enumeration values describe the possible
// transitions between children in a Flap widget, as well as which areas can be
// swiped via Flap:swipe-to-open and Flap:swipe-to-close.
//
// New values may be added to this enum over time.
type FlapTransitionType int

const (
	// FlapTransitionTypeOver: flap slides over the content, which is dimmed.
	// When folded, only the flap can be swiped.
	FlapTransitionTypeOver FlapTransitionType = iota
	// FlapTransitionTypeUnder: content slides over the flap. Only the content
	// can be swiped.
	FlapTransitionTypeUnder
	// FlapTransitionTypeSlide: flap slides offscreen when hidden, neither the
	// flap nor content overlap each other. Both widgets can be swiped.
	FlapTransitionTypeSlide
)

func marshalFlapTransitionType(p uintptr) (interface{}, error) {
	return FlapTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// String returns the name in string for FlapTransitionType.
func (f FlapTransitionType) String() string {
	switch f {
	case FlapTransitionTypeOver:
		return "Over"
	case FlapTransitionTypeUnder:
		return "Under"
	case FlapTransitionTypeSlide:
		return "Slide"
	default:
		return fmt.Sprintf("FlapTransitionType(%d)", f)
	}
}

type Flap struct {
	gtk.Widget

	Swipeable
	gtk.Orientable
	*externglib.Object
}

func wrapFlap(obj *externglib.Object) *Flap {
	return &Flap{
		Widget: gtk.Widget{
			InitiallyUnowned: externglib.InitiallyUnowned{
				Object: obj,
			},
			Accessible: gtk.Accessible{
				Object: obj,
			},
			Buildable: gtk.Buildable{
				Object: obj,
			},
			ConstraintTarget: gtk.ConstraintTarget{
				Object: obj,
			},
			Object: obj,
		},
		Swipeable: Swipeable{
			Widget: gtk.Widget{
				InitiallyUnowned: externglib.InitiallyUnowned{
					Object: obj,
				},
				Accessible: gtk.Accessible{
					Object: obj,
				},
				Buildable: gtk.Buildable{
					Object: obj,
				},
				ConstraintTarget: gtk.ConstraintTarget{
					Object: obj,
				},
				Object: obj,
			},
		},
		Orientable: gtk.Orientable{
			Object: obj,
		},
		Object: obj,
	}
}

func marshalFlapper(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapFlap(obj), nil
}

// NewFlap creates a new Flap.
func NewFlap() *Flap {
	var _cret *C.GtkWidget // in

	_cret = C.adw_flap_new()

	var _flap *Flap // out

	_flap = wrapFlap(externglib.Take(unsafe.Pointer(_cret)))

	return _flap
}

// Native solves the ambiguous selector of this class or interface.
func (self *Flap) Native() uintptr {
	return self.Object.Native()
}

// Content gets the content widget for self
func (self *Flap) Content() gtk.Widgetter {
	var _arg0 *C.AdwFlap   // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))

	_cret = C.adw_flap_get_content(_arg0)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		_widget = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(gtk.Widgetter)
	}

	return _widget
}

// Flap gets the flap widget for self
func (self *Flap) Flap() gtk.Widgetter {
	var _arg0 *C.AdwFlap   // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))

	_cret = C.adw_flap_get_flap(_arg0)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		_widget = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(gtk.Widgetter)
	}

	return _widget
}

// FlapPosition gets the flap position for self.
func (self *Flap) FlapPosition() gtk.PackType {
	var _arg0 *C.AdwFlap    // out
	var _cret C.GtkPackType // in

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))

	_cret = C.adw_flap_get_flap_position(_arg0)

	var _packType gtk.PackType // out

	_packType = gtk.PackType(_cret)

	return _packType
}

// FoldDuration returns the amount of time (in milliseconds) that fold
// transitions in self will take.
func (self *Flap) FoldDuration() uint {
	var _arg0 *C.AdwFlap // out
	var _cret C.guint    // in

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))

	_cret = C.adw_flap_get_fold_duration(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// FoldPolicy gets the current fold policy of self. See
// adw_flap_set_fold_policy().
func (self *Flap) FoldPolicy() FlapFoldPolicy {
	var _arg0 *C.AdwFlap          // out
	var _cret C.AdwFlapFoldPolicy // in

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))

	_cret = C.adw_flap_get_fold_policy(_arg0)

	var _flapFoldPolicy FlapFoldPolicy // out

	_flapFoldPolicy = FlapFoldPolicy(_cret)

	return _flapFoldPolicy
}

// Folded gets whether self is currently folded.
//
// See Flap:fold-policy.
func (self *Flap) Folded() bool {
	var _arg0 *C.AdwFlap // out
	var _cret C.gboolean // in

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))

	_cret = C.adw_flap_get_folded(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Locked gets whether self is locked.
func (self *Flap) Locked() bool {
	var _arg0 *C.AdwFlap // out
	var _cret C.gboolean // in

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))

	_cret = C.adw_flap_get_locked(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Modal gets whether the self is modal. See adw_flap_set_modal().
func (self *Flap) Modal() bool {
	var _arg0 *C.AdwFlap // out
	var _cret C.gboolean // in

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))

	_cret = C.adw_flap_get_modal(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RevealDuration returns the amount of time (in milliseconds) that reveal
// transitions in self will take.
func (self *Flap) RevealDuration() uint {
	var _arg0 *C.AdwFlap // out
	var _cret C.guint    // in

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))

	_cret = C.adw_flap_get_reveal_duration(_arg0)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// RevealFlap gets whether the flap widget is revealed for self.
func (self *Flap) RevealFlap() bool {
	var _arg0 *C.AdwFlap // out
	var _cret C.gboolean // in

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))

	_cret = C.adw_flap_get_reveal_flap(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RevealProgress gets the current reveal transition progress for self. 0 means
// fully hidden, 1 means fully revealed. See Flap:reveal-flap.
func (self *Flap) RevealProgress() float64 {
	var _arg0 *C.AdwFlap // out
	var _cret C.double   // in

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))

	_cret = C.adw_flap_get_reveal_progress(_arg0)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Separator gets the separator widget for self.
func (self *Flap) Separator() gtk.Widgetter {
	var _arg0 *C.AdwFlap   // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))

	_cret = C.adw_flap_get_separator(_arg0)

	var _widget gtk.Widgetter // out

	if _cret != nil {
		_widget = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(gtk.Widgetter)
	}

	return _widget
}

// SwipeToClose gets whether self can be closed with a swipe gesture.
func (self *Flap) SwipeToClose() bool {
	var _arg0 *C.AdwFlap // out
	var _cret C.gboolean // in

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))

	_cret = C.adw_flap_get_swipe_to_close(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SwipeToOpen gets whether self can be opened with a swipe gesture.
func (self *Flap) SwipeToOpen() bool {
	var _arg0 *C.AdwFlap // out
	var _cret C.gboolean // in

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))

	_cret = C.adw_flap_get_swipe_to_open(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TransitionType gets the type of animation that will be used for reveal and
// fold transitions in self.
func (self *Flap) TransitionType() FlapTransitionType {
	var _arg0 *C.AdwFlap              // out
	var _cret C.AdwFlapTransitionType // in

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))

	_cret = C.adw_flap_get_transition_type(_arg0)

	var _flapTransitionType FlapTransitionType // out

	_flapTransitionType = FlapTransitionType(_cret)

	return _flapTransitionType
}

// SetContent sets the content widget for self, always displayed when unfolded,
// and partially visible when folded.
func (self *Flap) SetContent(content gtk.Widgetter) {
	var _arg0 *C.AdwFlap   // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))
	if content != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(content.Native()))
	}

	C.adw_flap_set_content(_arg0, _arg1)
}

// SetFlap sets the flap widget for self, only visible when Flap:reveal-progress
// is greater than 0.
func (self *Flap) SetFlap(flap gtk.Widgetter) {
	var _arg0 *C.AdwFlap   // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))
	if flap != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(flap.Native()))
	}

	C.adw_flap_set_flap(_arg0, _arg1)
}

// SetFlapPosition sets the flap position for self. If GTK_PACK_START, the flap
// is displayed before the content, if GTK_PACK_END, it's displayed after the
// content.
func (self *Flap) SetFlapPosition(position gtk.PackType) {
	var _arg0 *C.AdwFlap    // out
	var _arg1 C.GtkPackType // out

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))
	_arg1 = C.GtkPackType(position)

	C.adw_flap_set_flap_position(_arg0, _arg1)
}

// SetFoldDuration sets the duration that fold transitions in self will take.
func (self *Flap) SetFoldDuration(duration uint) {
	var _arg0 *C.AdwFlap // out
	var _arg1 C.guint    // out

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))
	_arg1 = C.guint(duration)

	C.adw_flap_set_fold_duration(_arg0, _arg1)
}

// SetFoldPolicy sets the current fold policy for self. See FlapFoldPolicy for
// available policies.
func (self *Flap) SetFoldPolicy(policy FlapFoldPolicy) {
	var _arg0 *C.AdwFlap          // out
	var _arg1 C.AdwFlapFoldPolicy // out

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))
	_arg1 = C.AdwFlapFoldPolicy(policy)

	C.adw_flap_set_fold_policy(_arg0, _arg1)
}

// SetLocked sets whether self is locked.
//
// If FALSE, folding self when the flap is revealed automatically closes it, and
// unfolding it when the flap is not revealed opens it. If TRUE,
// Flap:reveal-flap value never changes on its own.
func (self *Flap) SetLocked(locked bool) {
	var _arg0 *C.AdwFlap // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))
	if locked {
		_arg1 = C.TRUE
	}

	C.adw_flap_set_locked(_arg0, _arg1)
}

// SetModal sets whether the self can be closed with a click.
//
// If modal is TRUE, clicking the content widget while flap is revealed, or
// pressing Escape key, will close the flap. If FALSE, clicks are passed through
// to the content widget.
func (self *Flap) SetModal(modal bool) {
	var _arg0 *C.AdwFlap // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.adw_flap_set_modal(_arg0, _arg1)
}

// SetRevealDuration sets the duration that reveal transitions in self will
// take.
func (self *Flap) SetRevealDuration(duration uint) {
	var _arg0 *C.AdwFlap // out
	var _arg1 C.guint    // out

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))
	_arg1 = C.guint(duration)

	C.adw_flap_set_reveal_duration(_arg0, _arg1)
}

// SetRevealFlap sets whether the flap widget is revealed for self.
func (self *Flap) SetRevealFlap(revealFlap bool) {
	var _arg0 *C.AdwFlap // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))
	if revealFlap {
		_arg1 = C.TRUE
	}

	C.adw_flap_set_reveal_flap(_arg0, _arg1)
}

// SetSeparator sets the separator widget for self, displayed between content
// and flap when there's no shadow to display. When exactly it's visible depends
// on the Flap:transition-type value. If NULL, no separator will be used.
func (self *Flap) SetSeparator(separator gtk.Widgetter) {
	var _arg0 *C.AdwFlap   // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))
	if separator != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(separator.Native()))
	}

	C.adw_flap_set_separator(_arg0, _arg1)
}

// SetSwipeToClose sets whether self can be closed with a swipe gesture.
//
// The area that can be swiped depends on the Flap:transition-type value.
func (self *Flap) SetSwipeToClose(swipeToClose bool) {
	var _arg0 *C.AdwFlap // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))
	if swipeToClose {
		_arg1 = C.TRUE
	}

	C.adw_flap_set_swipe_to_close(_arg0, _arg1)
}

// SetSwipeToOpen sets whether self can be opened with a swipe gesture.
//
// The area that can be swiped depends on the Flap:transition-type value.
func (self *Flap) SetSwipeToOpen(swipeToOpen bool) {
	var _arg0 *C.AdwFlap // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))
	if swipeToOpen {
		_arg1 = C.TRUE
	}

	C.adw_flap_set_swipe_to_open(_arg0, _arg1)
}

// SetTransitionType sets the type of animation that will be used for reveal and
// fold transitions in self.
//
// Flap:flap is transparent by default, which means the content will be seen
// through it with ADW_FLAP_TRANSITION_TYPE_OVER transitions; add the
// .background style class to it if this is unwanted.
func (self *Flap) SetTransitionType(transitionType FlapTransitionType) {
	var _arg0 *C.AdwFlap              // out
	var _arg1 C.AdwFlapTransitionType // out

	_arg0 = (*C.AdwFlap)(unsafe.Pointer(self.Native()))
	_arg1 = C.AdwFlapTransitionType(transitionType)

	C.adw_flap_set_transition_type(_arg0, _arg1)
}
